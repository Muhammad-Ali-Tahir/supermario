# supermario
------------------------ LEVEL1(Phase-1&2) ----------------------

Implementation:
The implementation of the code includes the printing of Mario, flag with crown shape on it and also pole of flag and the hurdles of different sizes.
The implementation of above is as follows:
 Implementation of pole:
For implementation of pole we used register al for the color of the pole and for height and starting position of pole register cx and dx are being used respectively. Then the value of register cx is pushed and the position of desired column and row is being moved in cx and si respectively and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position.
Implementation of flag:
For implementation of flag the same logic as used for pole is being used here. Register al is used for the color of the flag and register ah is used for the desired mode and for height and starting position of flag register cx and dx are being used respectively. Then the value of register cx is pushed and the position of desired column and row is being moved in cx and si respectively and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position.
Implementation of crown:
For implementation of crown the same logic as used for pole is being used for base of crown. Register al is used for the color of the crown and register ah is used for the desired mode and for height and starting position of crown register cx and dx are being used respectively. Then the value of register cx is pushed and the position of desired column and row is being moved in cx and si respectively and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position.
Whereas, for the left, right and middle side if crown the same logic as explained above is being with addition to that the position Is being moved in the crownX which has word data type and then later on crownX is again being used again for setting the columns again so that the whole crown is at the desired position. 
 Implementation of hurdles:
For implementation of hurdles the same logic as used for pole, flags is being used here. Register al is used for the color of the hurdles and register ah is used for the desired mode and for height, pixel in the start and starting position (along y-axis) of hurdle register cx and dx are being used respectively. Then the value of register cx is pushed and the position of desired column and row is being moved in cx and si respectively and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position.
Implementation of cloud:
For implementation of clouds, the almost same logic as used for pole, flags is being used here. Firstly, the required position of the cloud is being moved in bx and then it is added and subtracted respectively in cloudY and cloudX of word data type so that we can have cloud at the desired position. Register al is used for the color of the cloud and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) cloudY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the cloudX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print clouds.

Implementation of Mario
Head: 
For implementation of head of Mario, the almost same logic as used for pole, flags is being used here. Register al is used for the color of the head and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) marioY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the marioX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print head of Mario.
For Body:
For implementation of body of Mario, the almost same logic as used for pole, flags is being used here. Firstly, the required position of the body is being moved in bx and then it is added and subtracted respectively in marioY and marioX of word data type so that we can have body at the desired position. Register al is used for the color of the body and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) marioY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the marioX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print body of Mario.
For legs:
For implementation of legs of Mario, the almost same logic as used for pole, flags is being used here. Firstly, the required position of the body is being moved in bx and then it is added respectively in marioY and marioX of word data type so that we can have legs at the desired position. Register al is used for the color of the legs and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) marioY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the marioX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print legs of Mario.
For eyes:
For implementation of eyes of Mario, the almost same logic as used for pole, flags is being used here. Firstly, the required position of the body is being moved in bx and then it is added respectively in marioY and marioX of word data type so that we can have eyes at the desired position. Register al is used for the color of the eyes and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) marioY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the marioX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print eyes of Mario.
For mustache:
For implementation of mustache of Mario, the almost same logic as used for pole, flags is being used here. Firstly, the required position of the body is being moved in bx and then it is added respectively in marioY and marioX of word data type so that we can have mustache at the desired position. Register al is used for the color of the mustache and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) marioY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the marioX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print mustache of Mario.
For nose:
For implementation of nose of Mario, the almost same logic as used for pole, flags is being used here. Firstly, the required position of the body is being moved in bx and then it is added respectively in marioY and marioX of word data type so that we can have nose at the desired position. Register al is used for the color of the nose and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) marioY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the marioX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print nose of Mario.
For hat:
For implementation of hat of Mario, the almost same logic as used for pole, flags is being used here. Firstly, the required position of the body is being moved in bx and then it is added respectively in marioY and marioX of word data type so that we can have hat at the desired position. Register al is used for the color of the hat and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) marioY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the marioX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print hat of Mario.

Clear Mario:
The clear mario is used to regenerate mario when it collides with the hurdles or when it reaches the end of the level. The same logic of head, body, nose as explained above for mario is being used here for clear mario with addition that a word type label clearsaveX and clearsaveY is being used such that it saves the value of mario along x-axis and y-axis respectively so that mario is regenerated from the start whenever it collides the hurdles or reached the end of the level.

Implementation of movement:
For implementation of movement the upper arrow is being used for jump and the right arrow key is being used for right movement and the left arrow key is being used for left movement whereas the letter ‘E’ and ‘e’ is being used for exit. Their explanation is as follows:
For left movement:
For the left movement the register bx is being used for the speed that how fast the mario moves in left direction and then speed is being subtracted with marioX (which is position of mario along x-axis) so that the mario moves in the left direction and after that the functions mario clearmario and hurdletops are being called which are being used to recreate mario when it collides with the hurdles and then the positions are being given which are 620,320,150,480 which are positions of hurdles and the pole such that the programs end when mario reaches those positions(collides with hurdles or reaches the end of level i.e. at the pole) .
For right movement:
For the right movement the register bx is being used for the speed that how fast the mario moves in right direction and then speed is being added with marioX (which is position of mario along x-axis) so that the mario moves in the right direction and after that the functions mario clearmario and hurdletops are being called which are being used to recreate mario when it collides with the hurdles and then the positions are being given which are 620,320,150,480 which are positions of hurdles and the pole such that the programs end when mario reaches those positions(collides with hurdles or reaches the end of level i.e. at the pole)    
For up movement:
For the right movement the functions hurdletops, clearmario and Jump are being called which are being used to recreate mario when it collides with the hurdles and then the positions are being given which are 620,320,150,480 which are positions of hurdles and the pole such that the programs end when mario reaches those positions (collides with hurdles or reaches the end of level i.e.at the pole).
Implementation of jump:
When the up-arrow key is pressed the mario jumps. Here the register cx is used to get the value that how far the mario jumps whereas the bx is used for the height of the jump and the value of bx is being added and subtracted in marioX and marioY respectively (which is position along x-axis and y-axis respectively) so that when the up-arrow key is pressed the mario jumps by making a parabolic path and it can easily jump over hurdles.  


-------------------------------- LEVEL2(PHASE-3) ----------------------------
Implementation:
When mario reaches the flag the level 1 is completed and level 2 starts which also phase 3 of the game in this phase the making of mario, hurdles, flag, crown on flag, movement of mario is the same as explained above in phase 1&2 with addition to that there are 2 enemies in phase-3 which move and as soon as the mario touches the enemies the game ends.
Implementation of enemies:
Body:
For implementation of body of enemies, the almost same logic as used for pole, flags, mario is being used here. Firstly, the required position of the body is being moved in bx and then it is added and subtracted respectively in enemyY1 and enemyX1 of word data type so that we can have body at the desired position. Register al is used for the color of the body and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) enemyY1 of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the enemyX1 of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print body of enemy.
Eyes:
For implementation of eyes of enemies, the almost same logic as used for pole, flags, mario is being used here. Firstly, the required position of the body is being moved in bx and then it is added and subtracted respectively in enemyY1 and enemyX1 of word data type so that we can have eyes at the desired position. Register al is used for the color of the eyes and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) enemyY1 of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the enemyX1 of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print eyes of enemy.
Legs:
For implementation of legs of enemies, the almost same logic as used for pole, flags, mario is being used here. Firstly, the required position of the body is being moved in bx and then it is added and subtracted respectively in enemyY1 and enemyX1 of word data type so that we can have legs at the desired position. Register al is used for the color of the legs and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) enemyY1 of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the enemyX1 of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print legs of enemy.

In the same way the second enemy is printed
Enemy movement:
For enemy movement variable count of dword type is being compared with 200000 so that it controls the speed of enemy and enemy moves b/w the hurdles and then 0 is being moved in count and 1 is subtracted from enemyX1 and enemyX2 which is the position of enemy1 and enemy2 along x-axis respectively and due to this the enemy moves b/w the hurdles and as soon as mario touches the mario the game ends and msg of END GAME appears.  

-------------------------------- LEVEL3(PHASE-4) ----------------------------
Implementation:
When mario reaches the flag the level 2 is completed and level 3 starts which also phase 4 of the game in this phase the making of mario, hurdles, enemies, enemy movement, movement of mario is the same as explained above in phase 3 with addition to that there is a monster in phase-4 which moves and releases fire and as soon as the fire touches mario the game ends and the flag is replaced by castle in this phase.
Implementation of monster:
For body:
For implementation of body of monster, the almost same logic as used for pole, flags, mario, enemy is being used here. Firstly, the required position of the body is being moved in bx and then it is added and subtracted respectively in dragonY and dragonX of word data type so that we can have body at the desired position. Register al is used for the color of the body and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) dragonY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the dragonX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print body of monster.
For hand:
For implementation of hand of monster, the almost same logic as used for pole, flags, mario, enemy is being used here. Firstly, the required position of the hand is being moved in bx and then it is added and subtracted respectively in dragonY and dragonX of word data type so that we can have hand at the desired position. Register al is used for the color of the hand and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) dragonY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the dragonX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print hand of monster.
For eye:
For implementation of eye of monster, the almost same logic as used for pole, flags, mario, enemy is being used here. Firstly, the required position of the eye is being moved in bx and then it is added and subtracted respectively in dragonY and dragonX of word data type so that we can have eye at the desired position. Register al is used for the color of the eye and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) dragonY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the dragonX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print eye of monster.
For legs:
For implementation of legs of monster, the almost same logic as used for pole, flags, mario, enemy is being used here. Firstly, the required position of the legs is being moved in bx and then it is added and subtracted respectively in dragonY and dragonX of word data type so that we can have legs at the desired position. Register al is used for the color of the legs and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) dragonY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the dragonX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print legs of monster.
Monster movement:
For monster movement variable count of dword type is being compared with 200000 so that it controls the speed of monster and monster moves i.e. (it disappears and reappears and releases fires and also moves) and then 0 is being moved in count and 1 is subtracted from dragonX which is the position of monster along x-axis respectively and due to this the monster moves i.e. (it disappears and reappears and releases fires and also moves).

Monster fire:
For implementation of fire of monster, the almost same logic as used for pole, flags, mario, enemy is being used here. Firstly, there is a random function which generates fire at random positions and there is a variable var which shows thickness of fire. Required position of the fire is being moved in bx and then it is adjusted by adding and subtracting respectively in fireY and fireX of word data type so that we can have fire touch the mario (if they are at same position). Register al is used for the color of the fire and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) fireY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the fireX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print monster fire and as soon as the fire touches the mario the game ends and it prints message THE END.
Castle:
For implementation of castle, the almost same logic as used for pole, flags, mario, enemy is being used here. Firstly, the required position of the castle is being moved in bx and then it is added and subtracted respectively in castleY and castleX of word data type so that we can have castle at the desired position. Register al is used for the color of the castle and register ah is used for the desired mode and for height, pixel in the start register cx is used and for starting position (along y-axis) castleY of word data type is being moved in dx. Then the value of register cx is pushed and then for position (along x-axis) the castleX of word data type is being moved in cx and desired row is moved in si and then dx is being incremented to go to next row and then loop is being used to print the desired number of rows and to get to the desired position and print castle and as soon as the mario reaches the castle the game ends.

Outcomes:
The outcomes are that we are able to print the flag, the hurdles of different sizes and the body of Mario and monster and enemies and castle and also the mario can move right, left and can jump easily over the hurdles and enemies move and as soon as mario touches enemies the game ends and also monster moves and as soon as fire of monster touches mario the game ends and when mario touches castle the game is completed. 
